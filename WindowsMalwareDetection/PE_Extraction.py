import pefile,cpp_demangle

# Decode the mangled cpp function names
def decode_mangled_cpp(to_decode):
    to_decode_str = to_decode.decode('utf-8')
    print(to_decode_str)
    decoded_symbol = cpp_demangle.demangled(to_decode_str)
    print(type(decoded_symbol))
    return decoded_symbol
    
# Check for mangled C++ names
def is_mangled_cpp_name(function_name):
    function_name_str = function_name.decode('utf-8')
    return any(char in function_name_str for char in ['?', '$', '@'])

# Extract imported functions that the exe uses including cpp functions and the DLLs he uses
def imported_functions_and_DLLs(pe_file_path):
    pe = pefile.PE(pe_file_path)
    pe.parse_data_directories()
    dll_imported = list()
    imported_functions = list()
    cpp_mangle_imports = list()
    # Iterate through imported DLLs
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        dll_name = entry.dll.decode("utf-8")
        #if dll_name not in dll_imported:
        dll_imported.append(dll_name)
        for imp in entry.imports:
            if  imp.name != None: 
                if is_mangled_cpp_name(imp.name) == False:
                    name = imp.name.decode("utf-8")
                    imported_functions.append(name)
                else:
                    name = imp.name.decode("utf-8")
                    cpp_mangle_imports.append(name)   

    return dll_imported,imported_functions,cpp_mangle_imports

# Extract PE files 9 fields of 10 sections like in the database 
def PE_headers(pe_file_path):
    pe = pefile.PE(pe_file_path)
    
    # Create a dict of dos headers
    pe_headers = {
    "e_magic": pe.DOS_HEADER.e_magic,
    "e_cblp": pe.DOS_HEADER.e_cblp,
    "e_cp": pe.DOS_HEADER.e_cp,
    "e_crlc": pe.DOS_HEADER.e_crlc,
    "e_cparhdr": pe.DOS_HEADER.e_cparhdr,
    "e_minalloc": pe.DOS_HEADER.e_minalloc,
    "e_maxalloc": pe.DOS_HEADER.e_maxalloc,
    "e_ss": pe.DOS_HEADER.e_ss,
    "e_sp": pe.DOS_HEADER.e_sp,
    "e_csum": pe.DOS_HEADER.e_csum,
    "e_ip": pe.DOS_HEADER.e_ip,
    "e_cs": pe.DOS_HEADER.e_cs,
    "e_lfarlc": pe.DOS_HEADER.e_lfarlc,
    "e_ovno": pe.DOS_HEADER.e_ovno,
    "e_oemid": pe.DOS_HEADER.e_oemid,
    "e_oeminfo": pe.DOS_HEADER.e_oeminfo,
    "e_lfanew": pe.DOS_HEADER.e_lfanew }

    # Create a dict of file headers
    file_header_dict = {
    "Machine": pe.FILE_HEADER.Machine,
    "NumberOfSections": pe.FILE_HEADER.NumberOfSections,
    "TimeDateStamp": pe.FILE_HEADER.TimeDateStamp,
    "PointerToSymbolTable": pe.FILE_HEADER.PointerToSymbolTable,
    "NumberOfSymbols": pe.FILE_HEADER.NumberOfSymbols,
    "SizeOfOptionalHeader": pe.FILE_HEADER.SizeOfOptionalHeader,
    "Characteristics": pe.FILE_HEADER.Characteristics}

    # Create a dict of optional headers
    optional_header_dict = {
    "Magic": pe.OPTIONAL_HEADER.Magic,
    "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
    "MinorLinkerVersion": pe.OPTIONAL_HEADER.MinorLinkerVersion,
    "SizeOfCode": pe.OPTIONAL_HEADER.SizeOfCode,
    "SizeOfInitializedData": pe.OPTIONAL_HEADER.SizeOfInitializedData,
    "SizeOfUninitializedData": pe.OPTIONAL_HEADER.SizeOfUninitializedData,
    "AddressOfEntryPoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
    "BaseOfCode": pe.OPTIONAL_HEADER.BaseOfCode,
    "ImageBase": pe.OPTIONAL_HEADER.ImageBase,
    "SectionAlignment": pe.OPTIONAL_HEADER.SectionAlignment,
    "FileAlignment": pe.OPTIONAL_HEADER.FileAlignment,
    "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
    "MinorOperatingSystemVersion": pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
    "MajorImageVersion": pe.OPTIONAL_HEADER.MajorImageVersion,
    "MinorImageVersion": pe.OPTIONAL_HEADER.MinorImageVersion,
    "MajorSubsystemVersion": pe.OPTIONAL_HEADER.MajorSubsystemVersion,
    "MinorSubsystemVersion": pe.OPTIONAL_HEADER.MinorSubsystemVersion,
    "Reserved1": pe.OPTIONAL_HEADER.Reserved1,
    "SizeOfImage": pe.OPTIONAL_HEADER.SizeOfImage,
    "SizeOfHeaders": pe.OPTIONAL_HEADER.SizeOfHeaders,
    "CheckSum": pe.OPTIONAL_HEADER.CheckSum,
    "Subsystem": pe.OPTIONAL_HEADER.Subsystem,
    "DllCharacteristics": pe.OPTIONAL_HEADER.DllCharacteristics,
    "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
    "SizeOfHeapReserve": pe.OPTIONAL_HEADER.SizeOfHeapReserve,
    "SizeOfHeapCommit": pe.OPTIONAL_HEADER.SizeOfHeapCommit,
    "LoaderFlags": pe.OPTIONAL_HEADER.LoaderFlags,
    "NumberOfRvaAndSizes": pe.OPTIONAL_HEADER.NumberOfRvaAndSizes }

    # return a tuple of all the headers dicts
    pe_headers.update(file_header_dict)
    pe_headers.update(optional_header_dict)
    return pe_headers

# Extract PE files 9 fields of 10 sections like in the database 
def PE_sections(pe_file_path):
    pe = pefile.PE(pe_file_path)
    checked_sections =  (".text",".data",".rdata",".bss",".idata",".edata",".rsrc",".reloc",".tls",".pdata")
    pe_sections = dict()
    for section in pe.sections:
        section_name = str(section.Name.decode("utf-8")).replace('\x00', '').strip()
        for checked in checked_sections:
            if checked == section_name:
                pe_sections[section_name.strip(".")+"_Misc_VirtualSize"] = section.Misc_VirtualSize
                pe_sections[section_name.strip(".")+"_VirtualAddress"] = section.VirtualAddress
                pe_sections[section_name.strip(".")+"_SizeOfRawData"] = section.SizeOfRawData
                pe_sections[section_name.strip(".")+"_PointerToRawData"] = section.PointerToRawData
                pe_sections[section_name.strip(".")+"_PointerToRelocations"] = section.PointerToRelocations
                pe_sections[section_name.strip(".")+"_PointerToLinenumbers"] = section.PointerToLinenumbers
                pe_sections[section_name.strip(".")+"_NumberOfRelocations"] = section.NumberOfRelocations
                pe_sections[section_name.strip(".")+"_NumberOfLinenumbers"] = section.NumberOfLinenumbers
                pe_sections[section_name.strip(".")+"_Characteristics"] = section.Characteristics
    return pe_sections    